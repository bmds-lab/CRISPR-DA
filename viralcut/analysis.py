'''

Author: Jake Bradford

'''
import os
import json
import operator

from functools import reduce

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
sns.set_theme(style="white", rc={"axes.facecolor": (0, 0, 0, 0)})

from .data import get_assembly_cache

from ete3.ncbi_taxonomy.ncbiquery import NCBITaxa
from ete3.parser.newick import read_newick, write_newick
from plot_eteTree import *

def add_assembly_info_to_dataframe(dfIn, colAccession='accession', fieldsToAdd=['organismName', 'strain', 'taxId', 'assemblyInfo/assemblyLevel', 'assemblyInfo/assemblyName']):
    '''Given some DataFrame with column `colAccession`, add additional columns from the data report
    generated by NCBI.
    
    The schema is available here:
        https://www.ncbi.nlm.nih.gov/datasets/docs/v1/reference-docs/data-reports/genome-assembly/#ncbi-datasets-v1-reports-AssemblyDataReport
    
    Arguments:
        dfIn (DataFrame):      The DataFrame to add columns to
        colAccession (string): The name of the column containing NCBI accessions
        fieldsToAdd (list):    Fields from the data report (NCBI data_report.json) to add. 
                               To add items that are nested, separate each level using a forward-
                               slash. For example, `assemblyInfo/assemblyLevel`.

    Returns:
        The updated DataFrame (also edits in-place).
    '''
    
    # Load data reports for the accessions in the dataframe
    data_reports = {}   
    
    for accs in set(dfIn[colAccession]):
        fpReport = os.path.join(get_assembly_cache(accs), 'data_report.json')
        if os.path.exists(fpReport):
            with open(fpReport, 'r') as fp:
                data_reports[accs] = json.loads(fp.readline())

    # For those assemblies where we have a data report, add the requested columns to the dataframe
    for accs in data_reports:
        for fieldToAdd in fieldsToAdd:
        
            # inspiration from https://stackoverflow.com/a/14692747/12891825
            try:
                val = reduce(operator.getitem, fieldToAdd.split('/'), data_reports[accs])        
            except Exception as e:
                val = None
        
            dfIn.loc[dfIn[colAccession] == accs, fieldToAdd] = val
    
    return dfIn

def get_children(tree):
    return tree.children

def generate_phylogenetic_tree_from_tax_ids(tax_ids):
    with open('43740568-scores.csv', 'r') as fp:
        df = pd.read_csv(fp)
    
    df['local'] = 10000.0 / df['mit'] - 100.0
    #print(df)
    
    ncbi = NCBITaxa()
    tree = ncbi.get_topology(tax_ids)#, intermediate_nodes=True)
    tax2name, tax2track, tax2rank = ncbi.annotate_tree(tree)
    
    for idx, i in enumerate(tree.traverse(strategy="levelorder")):
        species = map(float, i.get_leaf_names())
        df_species = df[df['taxId'].isin(species)]
        mit = 10000.0 / (100.0 + df_species['local'].sum())
        i.mit = f"mit: {round(mit, 3)}"
        i.detailed_name = f"{tax2name[int(i.name)]} ({tax2rank[int(i.name)]})"
        
        if False:
            print(f"{i.name} {tax2name[int(i.name)]} ({tax2rank[int(i.name)]}) ({len(i.children)} children) ({len(i.get_leaf_names())} leaves): ")
            for x in i.children[0:5]:
                print(f"    {x.name} ({tax2rank[int(x.name)]}): {tax2name[int(x.name)]}")

            print(f"    mit score: {mit} (on {len(df_species)} observations)")
            print('\n')

            if idx == 8:
                break
    print(write_newick(ncbi.get_topology(ncbi.get_descendant_taxa(10240)), features=['name', 'detailed_name', 'mit']))
    #print(tree.get_ascii(attributes=['name', 'detailed_name', 'mit']))

    
    
    #nstyle = NodeStyle()
    #nstyle['fgcolor'] = 'red'
    #nstyle['hz_line_color'] = 'grey'
    #nstyle['hz_line_type'] = 0
    #nstyle['hz_line_width'] = 0
    #
    #nstyle2 = NodeStyle()
    #nstyle2['size'] = 8
    #nstyle2['shape'] = 'square'
    #nstyle2['fgcolor'] = 'green'
    #nstyle2['hz_line_color'] = 'orange'
    #nstyle2['hz_line_type'] = 1
    #nstyle2['vt_line_color'] = 'blue'
    #nstyle2['vt_line_width'] = 2
    #nstyle2['vt_line_type'] = 2
    #
    #for n in tree.iter_descendants():
    #    if n.is_leaf():
    #        n.set_style(nstyle)
    #    else:
    #        n.set_style(nstyle2)
    #tree.set_style(nstyle2)
    ######################################
    ### plot with matplotlib
    #fig, ax = plt.subplots(figsize=(25,50))
    #axe, coords = plot_tree(tree, axe=ax, attributes=['name', 'detailed_name', 'mit'])
    #fig.savefig('axe.png')   # save the figure to file

    


# def plot_scores_ridge()
#     # Create the data
#     rs = np.random.RandomState(1979)
#     x = rs.randn(500)
#     g = np.tile(list("ABCDEFGHIJ"), 50)
#     df = pd.DataFrame(dict(x=x, g=g))
#     m = df.g.map(ord)
#     df["x"] += m
# 
#     # Initialize the FacetGrid object
#     pal = sns.cubehelix_palette(10, rot=-.25, light=.7)
#     g = sns.FacetGrid(df, row="g", hue="g", aspect=15, height=.5, palette=pal)
# 
#     # Draw the densities in a few steps
#     g.map(sns.kdeplot, "x",
#           bw_adjust=.5, clip_on=False,
#           fill=True, alpha=1, linewidth=1.5)
#     g.map(sns.kdeplot, "x", clip_on=False, color="w", lw=2, bw_adjust=.5)
# 
#     # passing color=None to refline() uses the hue mapping
#     g.refline(y=0, linewidth=2, linestyle="-", color=None, clip_on=False)
# 
# 
#     # Define and use a simple function to label the plot in axes coordinates
#     def label(x, color, label):
#         ax = plt.gca()
#         ax.text(0, .2, label, fontweight="bold", color=color,
#                 ha="left", va="center", transform=ax.transAxes)
# 
# 
#     g.map(label, "x")
# 
#     # Set the subplots to overlap
#     g.figure.subplots_adjust(hspace=-.25)
# 
#     # Remove axes details that don't play well with overlap
#     g.set_titles("")
#     g.set(yticks=[], ylabel="")
#     g.despine(bottom=True, left=True)